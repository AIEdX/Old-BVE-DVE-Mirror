import { CalculateVoxelLight, VoxelLightMixCalc } from "./Functions/CalculateVoxelLight.js";
import { CalculateFlow } from "./Functions/CalculateFlow.js";
import { DataTool } from "../../../Tools/Data/DataTool.js";
/**# Chunk Processor
 * ---
 * Takes the given world data and generates templates
 * to build chunk meshes.
 */
export declare const Processor: {
    LOD: number;
    mDataTool: DataTool;
    nDataTool: DataTool;
    heightByte: {
        _getHeightMapData: Record<any, (byteData: number) => number>;
        _setHeightMapData: Record<any, (height: number, byteData: number) => number>;
        _markSubstanceAsNotExposed: Record<any, (data: number) => number>;
        _markSubstanceAsExposed: Record<any, (data: number) => number>;
        _isSubstanceExposed: Record<any, (data: number) => boolean>;
        getStartingHeightMapValue(): number;
        initalizeChunk(chunkData: DataView): void;
        updateChunkMinMax(voxelPOS: any, chunkData: DataView): void;
        getChunkMin(chunkData: DataView): number;
        getChunkMax(chunkData: DataView): number;
        calculateHeightRemoveDataForSubstance(height: number, substance: any, x: number, z: number, heightMap: DataView): boolean | undefined;
        calculateHeightAddDataForSubstance(height: number, substance: any, x: number, z: number, chunk: DataView): void;
        getLowestExposedVoxel(x: number, z: number, chunk: DataView): number;
        getHighestExposedVoxel(x: number, z: number, chunk: DataView): number;
        isSubstanceExposed(substance: any, x: number, z: number, chunk: DataView): boolean;
        markSubstanceAsExposed(substance: any, x: number, z: number, chunk: DataView): void;
        markSubstanceAsNotExposed(substance: any, x: number, z: number, chunk: DataView): void;
        setMinYForSubstance(height: number, substance: any, x: number, z: number, chunk: DataView): void;
        getMinYForSubstance(substance: any, x: number, z: number, chunk: DataView): number;
        setMaxYForSubstance(height: number, substance: any, x: number, z: number, chunk: DataView): void;
        getMaxYForSubstance(substance: any, x: number, z: number, chunk: DataView): number;
    };
    faceByte: {
        _rotationMap: Record<import("../../../Meta/Constructor/Mesher.types.js").Rotations, number>;
        _rotationReverseMap: Record<number, import("../../../Meta/Constructor/Mesher.types.js").Rotations>;
        _setFaceTextureState: Record<import("../../../Meta/Util.types.js").DirectionNames, (state: number, faceBit: number) => number>;
        _getFaceTextureState: Record<import("../../../Meta/Util.types.js").DirectionNames, (faceBit: number) => number>;
        _setFaceRotateState: Record<import("../../../Meta/Util.types.js").DirectionNames, (state: number, faceBit: number) => number>;
        _getFaceRotateState: Record<import("../../../Meta/Util.types.js").DirectionNames, (faceBit: number) => number>;
        _markExposedFace: Record<import("../../../Meta/Util.types.js").DirectionNames, (faceBit: number) => number>;
        _checkExposedFace: Record<import("../../../Meta/Util.types.js").DirectionNames, (faceBit: number) => boolean>;
        markFaceAsExposed(direction: import("../../../Meta/Util.types.js").DirectionNames, rawData: number): number;
        isFaceExposed(direction: import("../../../Meta/Util.types.js").DirectionNames, rawData: number): boolean;
        setFaceRotateState(direction: import("../../../Meta/Util.types.js").DirectionNames, state: number, rawData: number): number;
        getFaceRotateState(direction: import("../../../Meta/Util.types.js").DirectionNames, rawData: number): number;
        setFaceTextureState(direction: import("../../../Meta/Util.types.js").DirectionNames, rotation: import("../../../Meta/Constructor/Mesher.types.js").Rotations, rawData: number): number;
        getFaceTextureState(direction: import("../../../Meta/Util.types.js").DirectionNames, rawData: number): import("../../../Meta/Constructor/Mesher.types.js").Rotations;
    };
    lightData: {
        SRS: number;
        _lightValues: [any, number, any, number, any, number, any, number];
        getS(value: number): number;
        getR(value: number): number;
        getG(value: number): number;
        getB(value: number): number;
        setS(value: number, sl: number): number;
        setR(value: number, sl: number): number;
        setG(value: number, sl: number): number;
        setB(value: number, sl: number): number;
        removeS(sl: number): number;
        hasRGBLight(sl: number): boolean;
        getRGB(sl: number): number;
        setRGB(value: number, sl: number): number;
        decodeLightFromVoxelData(voxelData: number): number;
        encodeLightIntoVoxelData(voxelData: number, encodedLight: number): number;
        setLightValues(values: number[]): number;
        getLightValues(value: number): [any, number, any, number, any, number, any, number];
        isLessThanForRGBRemove(n1: number, n2: number): boolean;
        isLessThanForRGBAdd(n1: number, n2: number): boolean;
        isGreaterOrEqualThanForRGBRemove(n1: number, n2: number): boolean;
        getMinusOneForRGB(sl: number, nl: number): number;
        removeRGBLight(sl: number): number;
        getFullSunLight(sl: number): number;
        isLessThanForSunAdd(n1: number, n2: number): boolean;
        isLessThanForSunAddDown(n1: number, n2: number): boolean;
        isLessThanForSunAddUp(n1: number, n2: number): boolean;
        getSunLightForUnderVoxel(sl: number, nl: number): number;
        getMinusOneForSun(sl: number, nl: number): number;
        isLessThanForSunRemove(n1: number, sl: number): boolean;
        isGreaterOrEqualThanForSunRemove(n1: number, sl: number): boolean;
        sunLightCompareForDownSunRemove(n1: number, sl: number): boolean;
        removeSunLight(sl: number): number;
        minusOneForAll(sl: number): number;
    };
    calculatFlow: typeof CalculateFlow;
    voxellightMixCalc: typeof VoxelLightMixCalc;
    doVoxelLight: typeof CalculateVoxelLight;
    exposedFaces: number[];
    faceStates: number[];
    textureRotation: any[];
    settings: {
        doAO: boolean;
        doSun: boolean;
        doRGB: boolean;
        ignoreSun: boolean;
        entity: boolean;
        composedEntity: number;
    };
    voxelProcesseData: any;
    cullFaceOverrideData: any;
    aoOverRideData: any;
    template: any;
    faceIndexMap: Record<any, number>;
    dimension: number;
    $INIT(): void;
    cullCheck(face: any, voxelId: string, voxelShapeId: number, voxelSubstance: any, shapeState: number, x: number, y: number, z: number, faceBit: number): number;
    faceStateCheck(face: any, faceBit: number): number;
    _process(template: any, x: number, y: number, z: number, doSecondCheck?: boolean): void;
    constructEntity(composed?: number): any;
    makeAllChunkTemplates(dimension: number, chunk: any, chunkX: number, chunkY: number, chunkZ: number, LOD?: number): any;
    processVoxelLight(data: any, ignoreAO?: boolean): void;
    syncSettings(settings: any): void;
    flush(): void;
};
